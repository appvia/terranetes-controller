---
nameOverride: ""
# Override the naming scheme and force to this name
fullnameOverride: ""
# The number of replicas for the controller
replicaCount: 1

controller:
  # Is the port the builds apis
  port: 10080
  # Is the port the store api
  apiPort: 10081
  # Is the port for the metrics service
  metricsPort: 9090
  # The namespace to run all the jobs in
  namespace: default
  # Indicates if the controller should register its own CRDs
  registerCRDs: true
  # Executor secrets includes the following secrets in 'all' execution jobs. The secret is added
  # as an environment variables (spec.envFrom) into the terranetes container of the executor
  executorSecrets: []
  # Configuration related to costs
  costs:
    # Name of the secret containing the infracost api token
    # Naming format of values found https://www.infracost.io/docs/features/environment_variables/
    secret: ""
  # Configuration for the images used by the jobs
  images:
    # is the default image to use for terraform operations
    terraform: hashicorp/terraform:1.2.5
    # image to use for infracost
    infracost: infracost/infracost:0.10.8
    # policy is image for policy
    policy: bridgecrew/checkov:2.1.67
    # is the controller image
    controller: ghcr.io/appvia/terranetes-controller:v0.2.9
    # The terranetes image used when running jobs
    executor: ghcr.io/appvia/terranetes-executor:v0.2.9

  # driftInterval is the minimum time to check for drift
  driftInterval: 5h
  # driftThreshold is the percentage of configurations which are permitted
  # to run a drift detection at any one time
  driftThreshold: 0.10
  # driftControllerInterval is the interval the controller will use to requeue. On every iteration
  # the configurations are checked and anyone who's last plan occurred longer than the driftInterval
  # is up for a drift trigger. Its fine to have this low, it's the driftInterval and threshold which
  # ultimately effective jobs running to check drift.
  driftControllerInterval: 5m

  # Allows you to overload the templates
  templates:
    # is the name of config map holding a override to the job template
    job: ""

  # is the image pull policy
  imagePullPolicy: IfNotPresent
  # indicate we create the watcher jobs in user namespace, these allow users
  # to view the terraform output
  enableWatchers: true
  # enableTerraformVersions indicates configurations are permitted to override
  # the terraform version in their spec.
  enableTerraformVersions: true

  # The default terraform version (or tag of the above image)
  webhooks:
    # enables the webhooks
    enabled: true
    # is the port the webhooks is running
    port: 10250
    # creates the certificate authority
    ca: true
    # name of the file containing the certificate authority
    tlsAuthority: /certs/ca.pem
    # name of the file containing the tls certificate
    tlsCert: tls.pem
    # directory containing the above certificates
    tlsDir: /certs
    # name of the file containing the tls private key
    tlsKey: tls-key.pem

networkPolicies:
  # Indicates we should create the network policies
  enabled: true

imagePullSecrets: []

podAnnotations: {}

podSecurityContext:
  fsGroup: 65534
  runAsNonRoot: true
  runAsUser: 65534

securityContext:
  allowPrivilegeEscalation: false
  readOnlyRootFilesystem: true
  capabilities:
    drop:
      - all

# Allows to you deploy a number of providers into the clusters
providers:
#  - name: aws
#    source: injected
#    labels: {}
#    annotations: {}
#    # The cloud vendor this credentials is for
#    provider: aws|google|azurerm
#    # When using source secret we should have a secret name
#    secret: NAME
#    # When using source injected we should have a service account
#    serviceAccount: SERV

rbac:
  # Indicates we allow all service account in the controller namespace the role of
  # executor. This makes rolling out multiple providers backed to multiple services easier.
  # Service account used by executors need access to read and write secrets and leases in the
  # controller namespace (namely the controller-executor role)
  enableExecutorServiceAccountPermissions: false
  # Indicates we should create all the rbac
  create: true
  # service account for the controller
  controller:
    # Indicates we should provision the rbac
    create: true
    # annotations is a collection of annotations which should be added
    annotations: {}

  # Configuration for the terraform executor service account
  executor:
    # indicates we should create the terraform-executor service account
    create: true
    # annotations is a collection of annotations which should be added
    annotations: {}

# Allows to you to control via the helm chart the deployment of a number of
# security policy which govern what must be enforced in the controller and by
# the consumers.
policies:
#  - name: permitted_modules
#    labels: {}
#    annotations: {}
#    constraint:
#      modules:
#        allowed: []

resources: {}
  # These resources are applied to the controller
  # limits:
  #   cpu: 100m
  #   memory: 128Mi
  # requests:
  #   cpu: 100m
  #   memory: 128Mi

nodeSelector: {}

tolerations: []

affinity:
  podAntiAffinity:
    preferredDuringSchedulingIgnoredDuringExecution:
      - weight: 100
        podAffinityTerm:
          labelSelector:
            matchExpressions:
              - key: name
                operator: In
                values:
                  - controller
          topologyKey: failure-domain.beta.kubernetes.io/zone
      - weight: 95
        podAffinityTerm:
          labelSelector:
            matchExpressions:
              - key: name
                operator: In
                values:
                  - controller
          topologyKey: kubernetes.io/hostname
